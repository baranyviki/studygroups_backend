LOAD CSV FROM 'file:///C:/subjects.csv' AS line FIELDTERMINATOR ';'
CREATE (:Subject { subjectCode: line[0], SubjectName: toInteger(line[1]), 
credits : toInteger(line[2]), semester: line[3], rate:toInteger(line[4]), passed: line[5]})

CALL apoc.import.csv(
  [{fileName: 'file:///subjects.csv', labels: ['Subject']}],
  [],
  {delimiter: ';', arrayDelimiter: ',', stringIds: false}
)
CALL apoc.import.csv(
  [{fileName: 'file:///courses.csv', labels: ['Course']},
  {fileName: 'file:///subjects.csv', labels: ['Subject']},
  {fileName: 'file:///students.csv', labels: ['Student','User']},
  {fileName: 'file:///teachers.csv', labels: ['Teacher']}
  ],
  [{fileName: 'file:///courseSubject.csv', type: 'BELONGS_TO'},
  {fileName: 'file:///courseTeacher.csv', type: 'TEACHING'},
  {fileName: 'file:///subjectGrades.csv', type: 'ENROLLED_TO'},
  {fileName: 'file:///courseStudents.csv', type: 'ATTENDS'}
  ],
  {delimiter: ';', arrayDelimiter: ',', stringIds: false}
)

MATCH (u1:Student{UserID:10054} )-[:ENROLLED_TO]->(s:Subject{SubjectCode:'NAIPR1SAND'})<-[ENROLLED_TO]-(u2:Student)
MATCH (u1)--(c:Course {})--(u2)
RETURN u1,u2,s,c
LIMIT 100

--Azt keressük akinek ebben a félévben van közösen Prog1 velünk, 
--és van közös kurzus amire járunk:
MATCH (u1:Student{UserID:10054} )-[:ENROLLED_TO]->(s:Subject{SubjectCode:'NAIPR1SAND'})<-[ENROLLED_TO]-(u2:Student{UserID:10026})
MATCH (u1)--(c:Labour )--(u2)
MATCH (c)--(cs:Subject)
RETURN u1,u2,s,c,cs


MATCH (u1:Student{UserID:10054} )-[:ATTENDS]->(c:Course{CourseID:5003})<-[:ATTENDS]-(u2:Student)
MATCH (c)-[:BELONGS_TO]-(cs:Subject{SubjectCode:'NAIPR1SAND'})
RETURN u1,c,cs

MATCH (u1:Student)-[e:ENROLLED_TO]->(s:Subject)
WHERE u1.UserID =10054 AND s.SubjectID=1 //AND e.Grade = 1
RETURN apoc.meta.type(e.Grade)

címkék keresése node-on:
head([company IN $companies where company IN labels(node)])

constraint:
CREATE CONSTRAINT ON (user:USER) ASSERT user.UserID IS UNIQUE

CALL apoc.uuid.install('User', {addToExistingNodes: true, uuidProperty: 'UserID'}) yield label, installed, properties


course groups:
having another course in common:

MATCH (u1:Student)-[:ATTENDS]->(c1:Course)<-[:ATTENDS]-(u2:Student)
MATCH (u1)-[:ATTENDS]->(c2:Course)<-[:ATTENDS]-(u2)
WHERE u1.UserName = 'admin' AND c1.Semester = '2019/20/1' AND c1.CourseID='ded980bd-d91d-4748-b8cb-17668ab280a7' 
AND c2.Semester=c1.Semester AND c2.CourseType IN([1,2])
RETURN u1,c1,u2,c2

group by having:
match (u:User) 
WITH u.UserName as usr ,count(u.UserName) as cnt
WHERE cnt > 1
return usr, cnt
ORDER BY cnt desc

MATCH (n:User)-[r:ENROLLED_TO]->(s:Subject)
WHERE n.UserName="admin" AND r.Grade > 1 and s.SubjectCode='NAMVS1SAND'
MERGE (n)-[:TUTORING]->(s)
RETURN n,r,s

MATCH (u:User{UserID:"f55b6e6b-4119-4066-81b7-1069992c8fd2"})-[:ENROLLED_TO]->(s:Subject{SubjectID:"77f572a7-a2a9-425f-8a25-27ec14d073ec"})<-[r2:ENROLLED_TO]-(u2:Student),
(u)-[:ATTENDS]->(cCommon:Course{Semester:"2018/19/1"})<-[:ATTENDS]-(u2),
(u)-[:ATTENDS]->(c2:Course)-[:BELONGS_TO]->(s)<-[:BELONGS_TO]-(c3:Course)-[:ATTENDS]-(u2),
(c3)-[te]-(t:Teacher)
WHERE NOT (c2)<-[:TEACHING]-(t:Teacher)-[:TEACHING]->(c3)
ANd cCommon.CourseType IN ([1,2]) 
AND r2.Semester="2018/19/1" 
AND c2 <> c3
RETURN t,te,c2,c3
